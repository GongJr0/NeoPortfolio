{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NeoPortfolio NeoPortfolio is a tool created to address the backwards-looking approach of the Modern Portfolio Theory (MPT). The tool combines traditional MPT with Machine Learning (ML) models to predict stock returns and sentiment analysis to adjust return expectations based on media outlook. Why not just use MPT? There are multiple shortcomings of MPT that swayed the analysts and investors to develop multiple alternative approaches. The work of Harry Markowitz, although worthy of the Nobel Prize in Economics, is not widely used due to inconveniences and assumptions that are not always true. Fully historical return expectations MPT takes a fully historical approach to predicting the future and does it through simple averages. Therefore, the returns calculated in the traditional MPT are not always accurate and can be heavily biased by the past. Predicting the future does rely heavily on decomposing and analysing past data, the question is how to do it better. NeoPortfolio uses ML models to predict the future returns of stocks through lagged features. The process is designed to be simple and time-efficient to allow iterative optimization of multiple portfolios. By nature, an ML model ( RandomForestRegressor in this case) attempts to deduce the underlying patterns in the rate of change of returns instead of simply calculating an average. Given the model performance is satisfactory, (which is checked within the functions) the predictions will most likely be more accurate than the historical averages. In the case of lacking model performance, NeoPortfolio uses a fallback method of calculating the Exponentially Weighted Moving Average (EWMA) instead of the historical average. EWMA reduces the impact of past data and significantly reduces the possibility of a biased return expectation caused by past events. Above all, the return expectations are adjusted in accordance to the medias sentiment regarding the stock. FinBERT, a pre-trained Deep-Learning NLP model, is used to calculate sentiment scores for articles retrieved from NewsAPI. This last step ensures that the expectations of the public are incorporated into the expectations of the models. How would you optimize a non-existent portfolio with MPT? The main question NeoPortfolio aims to answer is not even addressed by MPT. MPT expects the investor to have a portfolio in his mind before starting the process of optimizing the weights. NeoPortfolio, however, provides a tool to identify the best portfolio (for a target return) to construct from the constituents of a market index. Using a combination engine and an iterative optimization algorithm, NeoPortfolio can find the weights and stocks to get the lowest possible risk for a given return. What NeoPortfolio doesn't fix Fluctuating Portfolio Weights If you have some experience with MPT you'll know that weights of the same portfolio can vary extremely on a day-to-day basis. The reason behind this is that MPT always returns the best possible portfolio. Naturally, a rational investor following MPT is then expected to reconstruct their portfolio every day to maintain the optimal weights. This is almost never applicable to a real-life scenario. NeoPortfolio chooses not to address this in the spirit of always returning the best possible option to the investors. The best choice based on mathematical processes is not always the best choice for each individual investor. Attempting to assume the specific needs and conditions of each investor would certainly lead to outputs that are far from optimal. Therefore, NopPortfolio sticks to the tried and true method of giving investors the mathematical solution and having them adjust the weights to their needs.","title":"Home"},{"location":"#neoportfolio","text":"NeoPortfolio is a tool created to address the backwards-looking approach of the Modern Portfolio Theory (MPT). The tool combines traditional MPT with Machine Learning (ML) models to predict stock returns and sentiment analysis to adjust return expectations based on media outlook.","title":"NeoPortfolio"},{"location":"#why-not-just-use-mpt","text":"There are multiple shortcomings of MPT that swayed the analysts and investors to develop multiple alternative approaches. The work of Harry Markowitz, although worthy of the Nobel Prize in Economics, is not widely used due to inconveniences and assumptions that are not always true.","title":"Why not just use MPT?"},{"location":"#fully-historical-return-expectations","text":"MPT takes a fully historical approach to predicting the future and does it through simple averages. Therefore, the returns calculated in the traditional MPT are not always accurate and can be heavily biased by the past. Predicting the future does rely heavily on decomposing and analysing past data, the question is how to do it better. NeoPortfolio uses ML models to predict the future returns of stocks through lagged features. The process is designed to be simple and time-efficient to allow iterative optimization of multiple portfolios. By nature, an ML model ( RandomForestRegressor in this case) attempts to deduce the underlying patterns in the rate of change of returns instead of simply calculating an average. Given the model performance is satisfactory, (which is checked within the functions) the predictions will most likely be more accurate than the historical averages. In the case of lacking model performance, NeoPortfolio uses a fallback method of calculating the Exponentially Weighted Moving Average (EWMA) instead of the historical average. EWMA reduces the impact of past data and significantly reduces the possibility of a biased return expectation caused by past events. Above all, the return expectations are adjusted in accordance to the medias sentiment regarding the stock. FinBERT, a pre-trained Deep-Learning NLP model, is used to calculate sentiment scores for articles retrieved from NewsAPI. This last step ensures that the expectations of the public are incorporated into the expectations of the models.","title":"Fully historical return expectations"},{"location":"#how-would-you-optimize-a-non-existent-portfolio-with-mpt","text":"The main question NeoPortfolio aims to answer is not even addressed by MPT. MPT expects the investor to have a portfolio in his mind before starting the process of optimizing the weights. NeoPortfolio, however, provides a tool to identify the best portfolio (for a target return) to construct from the constituents of a market index. Using a combination engine and an iterative optimization algorithm, NeoPortfolio can find the weights and stocks to get the lowest possible risk for a given return.","title":"How would you optimize a non-existent portfolio with MPT?"},{"location":"#what-neoportfolio-doesnt-fix","text":"","title":"What NeoPortfolio doesn't fix"},{"location":"#fluctuating-portfolio-weights","text":"If you have some experience with MPT you'll know that weights of the same portfolio can vary extremely on a day-to-day basis. The reason behind this is that MPT always returns the best possible portfolio. Naturally, a rational investor following MPT is then expected to reconstruct their portfolio every day to maintain the optimal weights. This is almost never applicable to a real-life scenario. NeoPortfolio chooses not to address this in the spirit of always returning the best possible option to the investors. The best choice based on mathematical processes is not always the best choice for each individual investor. Attempting to assume the specific needs and conditions of each investor would certainly lead to outputs that are far from optimal. Therefore, NopPortfolio sticks to the tried and true method of giving investors the mathematical solution and having them adjust the weights to their needs.","title":"Fluctuating Portfolio Weights"},{"location":"Markowitz/","text":"Markowitz Markowitz perform optimization to the weights of a known portfolio through Modern Portfolio Theory (MPT). Added to the traditional MPT are Machine Learning models to predict stock returns and sentiment analysis adjust return expectations based on media outlook. Markowitz relies on ReturnPred , Sentiment , and Cache modules on the backend. None of the listed modules are user-facing. __init__ Arguments portfolio -> Portfolio : A Portfolio object containing stock symbols. market -> IndexSymbol : Market index symbol. horizon -> Days : Investment horizon in days. lookback -> Days : Historical data lookback period in days. rf_rate_pa -> Optional[float] : Risk-free rate of return per annum. (10 Year US Treasury yield if None) api_key_path -> Optional[str | os.PathLike] : Path to the .env file containing a NewsAPI key. api_key_var -> Optional[str] : Name of the environment variable containing the NewsAPI key. Attributes portfolio -> Portfolio : A Portfolio object containing stock symbols. names -> dict[StockSymbol, str] : Short names of the companies issuing the stocks. market -> yfinance.Ticker : Market index. market_name -> str : Name of the market index. (often times the symbol) rf -> float : Risk-free rate of return for the investment period. (not per annum) raw_close -> pandas.DataFrame : Historical closing prices of the stocks. periodic_return -> pandas.DataFrame : Periodic returns of the stocks. expected_returns -> pandas.DataFrame : Expected returns of the stocks. volatility -> pandas.Series : Volatility of the stocks. market_returns -> pandas.Series : Market returns. market_volatility -> float : Market volatility. rm -> float : Market expected return. (historical average) cov_matrix -> pandas.DataFrame : Covariance matrix of the stocks. beta -> list[float] : Beta values of the stocks. Methods optimize_return Optimize the portfolio for a target return. Parameters: target_return: float : Target return for the portfolio. additional_constraints: Optioonal[list] : Additional constraints formatted to be passed to scipy.optimize.minimize . bounds: tuple[float, float] : Tuple containing the lower and upper bounds for the weights. include_beta: bool : Include beta values in the optimization. record: bool : Record the optimization results in the Portfolio object. Returns: tuple[dict, scipy.optimize.OptimizeResult] : A tuple containing the optimized weights and the optimization result. optimize_volatility Optimize the portfolio for a target volatility. Parameters: target_volatility: float : Target volatility for the portfolio. additional_constraints: Optioonal[list] : Additional constraints formatted to be passed to scipy.optimize.minimize . bounds: tuple[float, float] : Tuple containing the lower and upper bounds for the weights. include_beta: bool : Include beta values in the optimization. record: bool : Record the optimization results in the Portfolio object. Returns: tuple[dict, scipy.optimize.OptimizeResult] : A tuple containing the optimized weights and the optimization result. efficient_frontier Plot the efficient frontier. Parameters: - target_input: Literal['return', 'volatility'] : The target input for the efficient frontier. - n: int : Number of points to plot on the efficient frontier. - save: bool : Save the plot as a .png file. Returns: - None","title":"Markowitz"},{"location":"Markowitz/#markowitz","text":"Markowitz perform optimization to the weights of a known portfolio through Modern Portfolio Theory (MPT). Added to the traditional MPT are Machine Learning models to predict stock returns and sentiment analysis adjust return expectations based on media outlook. Markowitz relies on ReturnPred , Sentiment , and Cache modules on the backend. None of the listed modules are user-facing.","title":"Markowitz"},{"location":"Markowitz/#__init__-arguments","text":"portfolio -> Portfolio : A Portfolio object containing stock symbols. market -> IndexSymbol : Market index symbol. horizon -> Days : Investment horizon in days. lookback -> Days : Historical data lookback period in days. rf_rate_pa -> Optional[float] : Risk-free rate of return per annum. (10 Year US Treasury yield if None) api_key_path -> Optional[str | os.PathLike] : Path to the .env file containing a NewsAPI key. api_key_var -> Optional[str] : Name of the environment variable containing the NewsAPI key.","title":"__init__ Arguments"},{"location":"Markowitz/#attributes","text":"portfolio -> Portfolio : A Portfolio object containing stock symbols. names -> dict[StockSymbol, str] : Short names of the companies issuing the stocks. market -> yfinance.Ticker : Market index. market_name -> str : Name of the market index. (often times the symbol) rf -> float : Risk-free rate of return for the investment period. (not per annum) raw_close -> pandas.DataFrame : Historical closing prices of the stocks. periodic_return -> pandas.DataFrame : Periodic returns of the stocks. expected_returns -> pandas.DataFrame : Expected returns of the stocks. volatility -> pandas.Series : Volatility of the stocks. market_returns -> pandas.Series : Market returns. market_volatility -> float : Market volatility. rm -> float : Market expected return. (historical average) cov_matrix -> pandas.DataFrame : Covariance matrix of the stocks. beta -> list[float] : Beta values of the stocks.","title":"Attributes"},{"location":"Markowitz/#methods","text":"","title":"Methods"},{"location":"Markowitz/#optimize_return","text":"Optimize the portfolio for a target return. Parameters: target_return: float : Target return for the portfolio. additional_constraints: Optioonal[list] : Additional constraints formatted to be passed to scipy.optimize.minimize . bounds: tuple[float, float] : Tuple containing the lower and upper bounds for the weights. include_beta: bool : Include beta values in the optimization. record: bool : Record the optimization results in the Portfolio object. Returns: tuple[dict, scipy.optimize.OptimizeResult] : A tuple containing the optimized weights and the optimization result.","title":"optimize_return"},{"location":"Markowitz/#optimize_volatility","text":"Optimize the portfolio for a target volatility. Parameters: target_volatility: float : Target volatility for the portfolio. additional_constraints: Optioonal[list] : Additional constraints formatted to be passed to scipy.optimize.minimize . bounds: tuple[float, float] : Tuple containing the lower and upper bounds for the weights. include_beta: bool : Include beta values in the optimization. record: bool : Record the optimization results in the Portfolio object. Returns: tuple[dict, scipy.optimize.OptimizeResult] : A tuple containing the optimized weights and the optimization result.","title":"optimize_volatility"},{"location":"Markowitz/#efficient_frontier","text":"Plot the efficient frontier. Parameters: - target_input: Literal['return', 'volatility'] : The target input for the efficient frontier. - n: int : Number of points to plot on the efficient frontier. - save: bool : Save the plot as a .png file. Returns: - None","title":"efficient_frontier"},{"location":"Portfolio/","text":"Portfolio Portfolio is an extension to the standard tuple class. The arguments passed on instantiation (stock symbols) will be stored in a tuple and can be accessed using numerical indices. Additionally, using stock symbols as string indices will return relevant information about the stock. __init__ Arguments *args: Stock symbols to be added to the portfolio. Attributes results : A nested dict containing stock information. First level keys: 'weights', 'expected_returns', 'volatility', 'beta', 'sharpe_ratio', 'sentiment' Second level keys: Stock symbols - optimum_portfolio_info : A dictionary containing summary information regarding the optimized portfolio. - Keys: 'target_return', 'target_volatility', 'weights', 'risk_per_return' - weights : A dictionary of stock symbols and their respective weights in the portfolio. - tickers : A yfinance.Tickers object containing initialized with stocks passed to Portfolio .","title":"Portfolio"},{"location":"Portfolio/#portfolio","text":"Portfolio is an extension to the standard tuple class. The arguments passed on instantiation (stock symbols) will be stored in a tuple and can be accessed using numerical indices. Additionally, using stock symbols as string indices will return relevant information about the stock.","title":"Portfolio"},{"location":"Portfolio/#__init__-arguments","text":"*args: Stock symbols to be added to the portfolio.","title":"__init__ Arguments"},{"location":"Portfolio/#attributes","text":"results : A nested dict containing stock information. First level keys: 'weights', 'expected_returns', 'volatility', 'beta', 'sharpe_ratio', 'sentiment' Second level keys: Stock symbols - optimum_portfolio_info : A dictionary containing summary information regarding the optimized portfolio. - Keys: 'target_return', 'target_volatility', 'weights', 'risk_per_return' - weights : A dictionary of stock symbols and their respective weights in the portfolio. - tickers : A yfinance.Tickers object containing initialized with stocks passed to Portfolio .","title":"Attributes"},{"location":"QuickStart/","text":"Installation NeoPortfolio can be installed through pip with the following command: python -m pip install NeoPortfolio You can visit the GitHub repository or PyPI page to access the source code. Quick Start NeoPortfolio offers optimization tools for pre-determined portfolios a search tool to find the optimal portfolio from an index's constituents. MPT Optimization for Pre-Determined Portfolio from NeoPortfolio import Portfolio, Markowitz # Create a portfolio object and pass it to the Markowitz class portfolio = Portfolio(['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']) markowitz = Markowitz( portfolio=portfolio, market='^GSPC', # S&P 500 horizon= 21, lookback=252, rf_rate_pa=None, # Use 10-Year US Treasury yield if None api_key_path='path/to/api_key.env', # NewsAPI key api_key_var='YOUR_VAR_NAME' ) # Run the optimization weights, opt = markowitz.optimize_return(target_return=0.05, bounds=(0.05, 0.70), include_beta=True) print(weights) # Plot the efficient frontier markowitz.efficient_frontier('return', n=500) Automatic Portfolio Selection from NeoPortfolio import nCrOptimize ncr = nCrOptimize( market='^GSPC', # S&P 500 n=5, # Number of stocks in the portfolio target_return=0.05, horizon=21, lookback=252, api_key_path='path/to/api_key.env', # NewsAPI key api_key_var='YOUR_VAR_NAME' ) # Run the optimization results = ncr.optimize_space(bounds=(0.05, 0.70)) results.best_portfolio(display=True)","title":"Quick Start"},{"location":"QuickStart/#installation","text":"NeoPortfolio can be installed through pip with the following command: python -m pip install NeoPortfolio You can visit the GitHub repository or PyPI page to access the source code.","title":"Installation"},{"location":"QuickStart/#quick-start","text":"NeoPortfolio offers optimization tools for pre-determined portfolios a search tool to find the optimal portfolio from an index's constituents.","title":"Quick Start"},{"location":"QuickStart/#mpt-optimization-for-pre-determined-portfolio","text":"from NeoPortfolio import Portfolio, Markowitz # Create a portfolio object and pass it to the Markowitz class portfolio = Portfolio(['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']) markowitz = Markowitz( portfolio=portfolio, market='^GSPC', # S&P 500 horizon= 21, lookback=252, rf_rate_pa=None, # Use 10-Year US Treasury yield if None api_key_path='path/to/api_key.env', # NewsAPI key api_key_var='YOUR_VAR_NAME' ) # Run the optimization weights, opt = markowitz.optimize_return(target_return=0.05, bounds=(0.05, 0.70), include_beta=True) print(weights) # Plot the efficient frontier markowitz.efficient_frontier('return', n=500)","title":"MPT Optimization for Pre-Determined Portfolio"},{"location":"QuickStart/#automatic-portfolio-selection","text":"from NeoPortfolio import nCrOptimize ncr = nCrOptimize( market='^GSPC', # S&P 500 n=5, # Number of stocks in the portfolio target_return=0.05, horizon=21, lookback=252, api_key_path='path/to/api_key.env', # NewsAPI key api_key_var='YOUR_VAR_NAME' ) # Run the optimization results = ncr.optimize_space(bounds=(0.05, 0.70)) results.best_portfolio(display=True)","title":"Automatic Portfolio Selection"},{"location":"nCrOptimize/","text":"nCrOptimize nCrOptimize is a class that performs optimization on a search space of nCr combinations of stocks from a market index. It employs aggressive elimination processes to reduce the members of the combination space to keep compute times reasonable. nCrOptimize is programmed to cache results on each iteration to retain information from interrupted runs. nCrOptimize relies on nCrEngine , ReturnPred , Sentiment , and Cache modules on the backend. None of the listed modules are user-facing. __init__ Arguments market -> IndexSymbol : Market index symbol. n -> int : Number of stocks in the portfolio. target_return -> float : Target return for the portfolio. horizon -> Days : Investment horizon in days. lookback -> Days : Historical data lookback period in days. max_pool_size -> Optional[int] : Maximum number of combinations to consider. api_key_path -> Optional[str | os.PathLike] : Path to the .env file containing a NewsAPI key. api_key_var -> Optional[str] : Name of the environment variable containing the NewsAPI key. Attributes api_key_path -> Optional[str | os.PathLike] : Path to the .env file containing a NewsAPI key. key_var -> Optional[str] : Name of the environment variable containing the NewsAPI key. portfolio_cache -> PortfolioCache : Cache.PortfolioCache object. portfolios -> list[Portfolio] : List of Portfolio objects created from combinations. market_returns -> pandas.Series : Market returns. rf_rate -> float : Risk-free rate of return for the investment period. (not per annum) Methods optimize_space Optimize the search space of nCr combinations. Parameters: - bounds: tuple[float, float] : Tuple containing the lower and upper bounds for the weights. Returns: - nCrResult : An object containing the results of the optimization.","title":"nCrOptimize"},{"location":"nCrOptimize/#ncroptimize","text":"nCrOptimize is a class that performs optimization on a search space of nCr combinations of stocks from a market index. It employs aggressive elimination processes to reduce the members of the combination space to keep compute times reasonable. nCrOptimize is programmed to cache results on each iteration to retain information from interrupted runs. nCrOptimize relies on nCrEngine , ReturnPred , Sentiment , and Cache modules on the backend. None of the listed modules are user-facing.","title":"nCrOptimize"},{"location":"nCrOptimize/#__init__-arguments","text":"market -> IndexSymbol : Market index symbol. n -> int : Number of stocks in the portfolio. target_return -> float : Target return for the portfolio. horizon -> Days : Investment horizon in days. lookback -> Days : Historical data lookback period in days. max_pool_size -> Optional[int] : Maximum number of combinations to consider. api_key_path -> Optional[str | os.PathLike] : Path to the .env file containing a NewsAPI key. api_key_var -> Optional[str] : Name of the environment variable containing the NewsAPI key.","title":"__init__ Arguments"},{"location":"nCrOptimize/#attributes","text":"api_key_path -> Optional[str | os.PathLike] : Path to the .env file containing a NewsAPI key. key_var -> Optional[str] : Name of the environment variable containing the NewsAPI key. portfolio_cache -> PortfolioCache : Cache.PortfolioCache object. portfolios -> list[Portfolio] : List of Portfolio objects created from combinations. market_returns -> pandas.Series : Market returns. rf_rate -> float : Risk-free rate of return for the investment period. (not per annum)","title":"Attributes"},{"location":"nCrOptimize/#methods","text":"","title":"Methods"},{"location":"nCrOptimize/#optimize_space","text":"Optimize the search space of nCr combinations. Parameters: - bounds: tuple[float, float] : Tuple containing the lower and upper bounds for the weights. Returns: - nCrResult : An object containing the results of the optimization.","title":"optimize_space"},{"location":"nCrResult/","text":"nCrResult nCrResult extends the standard list class and contains the results of the optimization performed by nCrOptimize for each combination of stocks. It provides methods to explore the optimized combination space and automatically create HTML reports for the best portfolios, outputted by Ipython.display.HTML and Ipython.display.display . Methods best_portfolio Display the best portfolio (determined by $score = \\frac{\\mu_{expected}}{\\sigma^2}$ ) Parameters: - display: bool : Create an HTML report and display it if True. Else return the results as a dictionary. Returns: - Optional[dict] : A dictionary containing the best portfolio's information. max_return Display the portfolio with the highest expected return. Parameters: - display: bool : Create an HTML report and display it if True. Else return the results as a dictionary. Returns: - Optional[dict] : A dictionary containing the portfolio with the highest expected return's information. min_volatility Display the portfolio with the lowest volatility. Parameters: - display: bool : Create an HTML report and display it if True. Else return the results as a dictionary. Returns: - Optional[dict] : A dictionary containing the portfolio with the lowest volatility's information. window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']], displayMath: [[\"$$\", \"$$\"], ['\\\\[', '\\\\]']], packages: { '[+]': ['mhchem'] } }, loader: { load: ['[tex]/mhchem'] }, }","title":"nCrResult"},{"location":"nCrResult/#ncrresult","text":"nCrResult extends the standard list class and contains the results of the optimization performed by nCrOptimize for each combination of stocks. It provides methods to explore the optimized combination space and automatically create HTML reports for the best portfolios, outputted by Ipython.display.HTML and Ipython.display.display .","title":"nCrResult"},{"location":"nCrResult/#methods","text":"","title":"Methods"},{"location":"nCrResult/#best_portfolio","text":"Display the best portfolio (determined by $score = \\frac{\\mu_{expected}}{\\sigma^2}$ ) Parameters: - display: bool : Create an HTML report and display it if True. Else return the results as a dictionary. Returns: - Optional[dict] : A dictionary containing the best portfolio's information.","title":"best_portfolio"},{"location":"nCrResult/#max_return","text":"Display the portfolio with the highest expected return. Parameters: - display: bool : Create an HTML report and display it if True. Else return the results as a dictionary. Returns: - Optional[dict] : A dictionary containing the portfolio with the highest expected return's information.","title":"max_return"},{"location":"nCrResult/#min_volatility","text":"Display the portfolio with the lowest volatility. Parameters: - display: bool : Create an HTML report and display it if True. Else return the results as a dictionary. Returns: - Optional[dict] : A dictionary containing the portfolio with the lowest volatility's information. window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']], displayMath: [[\"$$\", \"$$\"], ['\\\\[', '\\\\]']], packages: { '[+]': ['mhchem'] } }, loader: { load: ['[tex]/mhchem'] }, }","title":"min_volatility"}]}