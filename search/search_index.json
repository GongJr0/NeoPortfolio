{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NeoPortfolio NeoPortfolio is a tool created to address the backwards-looking approach of the Modern Portfolio Theory (MPT). The tool combines traditional MPT with Machine Learning (ML) models to predict stock returns and sentiment analysis to adjust return expectations based on media outlook. Why not just use MPT? There are multiple shortcomings of MPT that swayed the analysts and investors to develop multiple alternative approaches. The work of Harry Markowitz, although worthy of the Nobel Prize in Economics, is not widely used due to inconveniences and assumptions that are not always true. Fully historical return expectations MPT takes a fully historical approach to predicting the future and does it through simple averages. Therefore, the returns calculated in the traditional MPT are not always accurate and can be heavily biased by the past. Predicting the future does rely heavily on decomposing and analysing past data, the question is how to do it better. NeoPortfolio uses ML models to predict the future returns of stocks through lagged features. The process is designed to be simple and time-efficient to allow iterative optimization of multiple portfolios. By nature, an ML model ( RandomForestRegressor in this case) attempts to deduce the underlying patterns in the rate of change of returns instead of simply calculating an average. Given the model performance is satisfactory, (which is checked within the functions) the predictions will most likely be more accurate than the historical averages. In the case of lacking model performance, NeoPortfolio uses a fallback method of calculating the Exponentially Weighted Moving Average (EWMA) instead of the historical average. EWMA reduces the impact of past data and significantly reduces the possibility of a biased return expectation caused by past events. Above all, the return expectations are adjusted in accordance to the medias sentiment regarding the stock. FinBERT, a pre-trained Deep-Learning NLP model, is used to calculate sentiment scores for articles retrieved from NewsAPI. This last step ensures that the expectations of the public are incorporated into the expectations of the models. How would you optimize a non-existent portfolio with MPT? The main question NeoPortfolio aims to answer is not even addressed by MPT. MPT expects the investor to have a portfolio in his mind before starting the process of optimizing the weights. NeoPortfolio, however, provides a tool to identify the best portfolio (for a target return) to construct from the constituents of a market index. Using a combination engine and an iterative optimization algorithm, NeoPortfolio can find the weights and stocks to get the lowest possible risk for a given return. What NeoPortfolio doesn't fix Fluctuating Portfolio Weights If you have some experience with MPT you'll know that weights of the same portfolio can vary extremely on a day-to-day basis. The reason behind this is that MPT always returns the best possible portfolio. Naturally, a rational investor following MPT is then expected to reconstruct their portfolio every day to maintain the optimal weights. This is almost never applicable to a real-life scenario. NeoPortfolio chooses not to address this in the spirit of always returning the best possible option to the investors. The best choice based on mathematical processes is not always the best choice for each individual investor. Attempting to assume the specific needs and conditions of each investor would certainly lead to outputs that are far from optimal. Therefore, NopPortfolio sticks to the tried and true method of giving investors the mathematical solution and having them adjust the weights to their needs.","title":"Home"},{"location":"#neoportfolio","text":"NeoPortfolio is a tool created to address the backwards-looking approach of the Modern Portfolio Theory (MPT). The tool combines traditional MPT with Machine Learning (ML) models to predict stock returns and sentiment analysis to adjust return expectations based on media outlook.","title":"NeoPortfolio"},{"location":"#why-not-just-use-mpt","text":"There are multiple shortcomings of MPT that swayed the analysts and investors to develop multiple alternative approaches. The work of Harry Markowitz, although worthy of the Nobel Prize in Economics, is not widely used due to inconveniences and assumptions that are not always true.","title":"Why not just use MPT?"},{"location":"#fully-historical-return-expectations","text":"MPT takes a fully historical approach to predicting the future and does it through simple averages. Therefore, the returns calculated in the traditional MPT are not always accurate and can be heavily biased by the past. Predicting the future does rely heavily on decomposing and analysing past data, the question is how to do it better. NeoPortfolio uses ML models to predict the future returns of stocks through lagged features. The process is designed to be simple and time-efficient to allow iterative optimization of multiple portfolios. By nature, an ML model ( RandomForestRegressor in this case) attempts to deduce the underlying patterns in the rate of change of returns instead of simply calculating an average. Given the model performance is satisfactory, (which is checked within the functions) the predictions will most likely be more accurate than the historical averages. In the case of lacking model performance, NeoPortfolio uses a fallback method of calculating the Exponentially Weighted Moving Average (EWMA) instead of the historical average. EWMA reduces the impact of past data and significantly reduces the possibility of a biased return expectation caused by past events. Above all, the return expectations are adjusted in accordance to the medias sentiment regarding the stock. FinBERT, a pre-trained Deep-Learning NLP model, is used to calculate sentiment scores for articles retrieved from NewsAPI. This last step ensures that the expectations of the public are incorporated into the expectations of the models.","title":"Fully historical return expectations"},{"location":"#how-would-you-optimize-a-non-existent-portfolio-with-mpt","text":"The main question NeoPortfolio aims to answer is not even addressed by MPT. MPT expects the investor to have a portfolio in his mind before starting the process of optimizing the weights. NeoPortfolio, however, provides a tool to identify the best portfolio (for a target return) to construct from the constituents of a market index. Using a combination engine and an iterative optimization algorithm, NeoPortfolio can find the weights and stocks to get the lowest possible risk for a given return.","title":"How would you optimize a non-existent portfolio with MPT?"},{"location":"#what-neoportfolio-doesnt-fix","text":"","title":"What NeoPortfolio doesn't fix"},{"location":"#fluctuating-portfolio-weights","text":"If you have some experience with MPT you'll know that weights of the same portfolio can vary extremely on a day-to-day basis. The reason behind this is that MPT always returns the best possible portfolio. Naturally, a rational investor following MPT is then expected to reconstruct their portfolio every day to maintain the optimal weights. This is almost never applicable to a real-life scenario. NeoPortfolio chooses not to address this in the spirit of always returning the best possible option to the investors. The best choice based on mathematical processes is not always the best choice for each individual investor. Attempting to assume the specific needs and conditions of each investor would certainly lead to outputs that are far from optimal. Therefore, NopPortfolio sticks to the tried and true method of giving investors the mathematical solution and having them adjust the weights to their needs.","title":"Fluctuating Portfolio Weights"},{"location":"BtEngine/","text":"BtEngine BtEngine is a backtesting module designed to accept close prices outputted by yfinance.Ticker or yfinance.Tickers . It employs a strategy stored in BtStrategy and iterates over the historical to test the performance of a portfolio when actively trading. __init__ Arguments portfolio_close -> pd.DataFrame : Close prices returned from yfinance strategy -> BtStrategy : BtStrategy object to handle signal generation hi_lo -> tuple[pandas.DataFrame, pandas.DataFrame] : Tuple of high and low price data from yfinance vol -> pandas.DataFrame : Volume data from yfinance Attributes cash -> float : Liquid assets (initial balance = 100,000) max_trade_proportion -> float : Maximum trade amount as a percentage of total holdings (default = 0.33) price_data -> pandas.DataFrame : Close prices from yfinance dt_index: pandas.DateIndex : Default index of the close price data hi -> pandas.DataFrame : High prices from yfinance lo -> pandas.DataFrame : Low prices from yfinance vol -> pandas.DataFrame : Volume data from yfinance sma_period -> int : Window for Short-Moving-Average (SMA) lma_period -> int : Window for Long-Moving-Average (LMA) strat: BtStrategy : Strategy container for signal generation holdings: dict[str, float] : Holdings for each stock (in shares) buy -> dict[str, list[tuple[str, float]]] : dict of each period (keys) where a buy signal was produced and a list tuples with format (stock_that_produced_buy_sig, strat_score) sell -> dict[str, list[tuple[str, float]]] : dict of each period (keys) where a sell signal was produced and a list tuples with format (stock_that_produced_buy_sig, strat_score) total_buys -> int : Count of total buy signals total_sells -> int : Count of total sell signals Methods set_holdings Method to set holdings using portfolio weights before the run. Params: - weights -> dict[str, float] : dict of stock symbols and their weights - inv_percent -> float : percentage of starting cash balance to invest in the portfolio Returns: None run Run the engine to perform iterative backtesting with the pre-determined strategy Params: - None Returns: dict[str, float | dict] : dict containing post-run portfolio value in USD, total liquid assets, and asset distribution as a dict of stocks and their respective holdings at the end of the run. plot_history Display a matplotlib.pyplot figure that contains key information regarding the performance of the selected backtesting strategy and portfolio. Params: - None Returns: - None","title":"BtEngine"},{"location":"BtEngine/#btengine","text":"BtEngine is a backtesting module designed to accept close prices outputted by yfinance.Ticker or yfinance.Tickers . It employs a strategy stored in BtStrategy and iterates over the historical to test the performance of a portfolio when actively trading.","title":"BtEngine"},{"location":"BtEngine/#__init__-arguments","text":"portfolio_close -> pd.DataFrame : Close prices returned from yfinance strategy -> BtStrategy : BtStrategy object to handle signal generation hi_lo -> tuple[pandas.DataFrame, pandas.DataFrame] : Tuple of high and low price data from yfinance vol -> pandas.DataFrame : Volume data from yfinance","title":"__init__ Arguments"},{"location":"BtEngine/#attributes","text":"cash -> float : Liquid assets (initial balance = 100,000) max_trade_proportion -> float : Maximum trade amount as a percentage of total holdings (default = 0.33) price_data -> pandas.DataFrame : Close prices from yfinance dt_index: pandas.DateIndex : Default index of the close price data hi -> pandas.DataFrame : High prices from yfinance lo -> pandas.DataFrame : Low prices from yfinance vol -> pandas.DataFrame : Volume data from yfinance sma_period -> int : Window for Short-Moving-Average (SMA) lma_period -> int : Window for Long-Moving-Average (LMA) strat: BtStrategy : Strategy container for signal generation holdings: dict[str, float] : Holdings for each stock (in shares) buy -> dict[str, list[tuple[str, float]]] : dict of each period (keys) where a buy signal was produced and a list tuples with format (stock_that_produced_buy_sig, strat_score) sell -> dict[str, list[tuple[str, float]]] : dict of each period (keys) where a sell signal was produced and a list tuples with format (stock_that_produced_buy_sig, strat_score) total_buys -> int : Count of total buy signals total_sells -> int : Count of total sell signals","title":"Attributes"},{"location":"BtEngine/#methods","text":"","title":"Methods"},{"location":"BtEngine/#set_holdings","text":"Method to set holdings using portfolio weights before the run. Params: - weights -> dict[str, float] : dict of stock symbols and their weights - inv_percent -> float : percentage of starting cash balance to invest in the portfolio Returns: None","title":"set_holdings"},{"location":"BtEngine/#run","text":"Run the engine to perform iterative backtesting with the pre-determined strategy Params: - None Returns: dict[str, float | dict] : dict containing post-run portfolio value in USD, total liquid assets, and asset distribution as a dict of stocks and their respective holdings at the end of the run.","title":"run"},{"location":"BtEngine/#plot_history","text":"Display a matplotlib.pyplot figure that contains key information regarding the performance of the selected backtesting strategy and portfolio. Params: - None Returns: - None","title":"plot_history"},{"location":"BtStrategy/","text":"BtStrategy BtStrategy is a strategy container developed for use inside a BtEngine object. It defines trading strategies and outputs scores based on the input data, selected strategy, and configurable thresholds. Available Strategies Crossover Crossover is a strategy where two moving averages of close prices compared. The Short Moving Average (SMA) is used to capture recent trends in price changes while the Long Moving Average (LMA) records the long-term movement of the close price. Crossover generates a buy or sell signal when a change in the price movement trend is detected. The trend comparison is made by comparing the SMA and LMA of the current period to the previous one in a relational setting: Buy Signal: $SMA_i \\geq LMA_i \\ \\text{and } SMA_{i-1} \\leq LMA_{i-1}$ (On periods where SMA crosses over LMA) Sell Signal: $SMA_i \\leq LMA_i \\ \\text{and } SMA_{i-1} \\geq LMA_{i-1}$ (On periods where LMA crosses over SMA) Hence, the strategy is named \"Crossover\" in reference to the relations it aims to capture. Signal magnitude is not measured in this strategy and all trades will be made with BtEngine.max_trade_proportion (0.33) of the asset traded. Relative Strength Index Relative Strength Index (RSI) is a common strategy that, again, takes moving averages as its basis. However, RSI relies on the average change of close prices instead of the absolute price. Relative Strength (RS) is calculated and scaled to the range $[0, 100]$ to get the RSI score. RS and its rescaling is done as follows: $$RS=\\frac{\\text{Average Gains}}{\\text{Average Losses}}$$ $$RSI = 100-\\frac{100}{1+RS}$$ Where $\\text{Average Gains}$ and $\\text{Average Losses}$ are the moving averages of positive and negative changes in price respectively. A buy signal is typically produced when $RSI \\leq 30$ and a sell is often placed at $RSI \\geq 70$ . BtStrategy offers Linear, Exponential, and Logistic Scaling for RSI strategies with Logistic Scaling being the default and best performing option. (per our testing) Fibonacci Retracement Fibonacci Retracement is a strategy relying on drawing brackets between the high and low prices from a period brackets are defined as percentiles in the $[Lo_{i-t:i}, Hi_{i-t:i}]$ range and the levels are drawn from the Fibonacci sequence. ( $FibLevels = {0.236, 0.382, 0.618, 0.786}$ ) Signals are generated as follows: $$ \\mathrm{FibSignal}(P_i) = \\begin{cases} \\text{Buy} & \\text{if } P_i \\leq P_{38.2\\text{%}} \\ \\text{Hold} & \\text{if } P_i \\in (P_{38.2\\text{%}}, \\ P_{61.8\\text{%}}) \\ \\text{Sell} & \\text{if } P_i \\geq P_{61.8\\text{%}} \\end{cases} $$ Similar to RSI, signal magnitude is achieved by mapping calculated Fib percentile of the current price to range $[0, 1]$ using on of the Linear, Exponential, and Logistic Scaling functions implemented. Again, the default and best performing function is determined to be the Logistic Scaling. (per our testing) Ichimoku Cloud Ichimoku Cloud is a strategy built on the moving averages of the range between high and low prices. Having the base formula: $$\\mathrm{Span}(t) = \\frac{Hi_{i-t: t} - Lo_{i-t: t}}{2}$$ Multiple moving averages are calculated with differing inputs as $t$ . Tenkan-sen ( $=\\mathrm{Span}(9)$ ): Captures the average range in the shortest rolling window Kijun-sen ( $=\\mathrm{Span}(26)$ ): Captures the average range in the mid-range rolling window Senkou Span B ( $=\\mathrm{Line}(52)$ ): Captures the average range in the longest rolling window Senkou Span A ( $\\frac{\\text{Tenkan-sen} + \\text{Kijun-sen}}{2}$ ): Captures the range between short and medium rolling spans Signals are generated as follows: $$\\mathrm{Ichimoku} = \\begin{cases} Buy & \\text{if} \\ \\text{Tenkan-sen > Kijun-sen} \\text{ and} P_i > \\max (Senkou_A, \\ Senkou_B) Sell & \\text{if} \\ \\text{Tenkan-sen < Kijun-sen} \\text{ and} P_i < \\min (Senkou_A, \\ Senkou_B) Hold & \\text{if} \\ \\text{Any other outcome} \\end{cases} $$ Ichimoku cloud signals do not generate scores with known bounds or midpoints, making signal scaling difficult. The approach taken in generating a signal magnitude for this strategy relies on clipping the final output to the range $[0, 1]$ with the assumption that magnitudes over 1 indicate a significantly strong signal and magnitudes less than 0 similarly indicate a significantly weak signal. Scaling is handled by the following functions: $$\\mathrm{CloudBoundary} = \\begin{cases} Senkou_A & \\text{if } \\ Signal = 1 \\ Senkou_B & \\text{if } \\ Signal = -1 \\end{cases}$$ $$\\text{Raw Magnitude} = \\frac{|P_i - CloudBoundary|}{Hi_i - Lo_i}$$ $$Magnitude = \\begin{cases} 1 & \\text{if } \\ \\text{Raw Magnitude} \\geq 1 \\ \\text{Raw Magnitude} & \\text{if } \\ \\text{Raw Magnitude} \\in (0, 1) \\ 0 & \\text{if } \\ \\text{Raw Magnitude} \\leq 0 \\end{cases}$$ __init__ Arguments strat: Literal['crossover', 'rsi_ma', 'rsi_ewma', 'fib_retracement', 'ichimoku_cloud'] : strategy to use when running a backtest Attributes strat -> str : Strategy to use on backtesting signal_scaler -> Callable : Signal magnitude mapper function to use depending on the selected strategy buy_threshold -> int : Buying signal threshold for RSI strategies sell_threshold -> int : Selling signal threshold for RSI strategies Methods set_thresholds sets the thresholds given a single value using buy_threshold = threshold; sell_threshold = (100-threshold) to keep a uniform range of signal generation space on both ends of RSI. Params: - threshold: int : threshold to determine buying and selling regions Returns: - None window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']], displayMath: [[\"$$\", \"$$\"], ['\\\\[', '\\\\]']], packages: { '[+]': ['mhchem'] } }, loader: { load: ['[tex]/mhchem'] }, }","title":"BtStrategy"},{"location":"BtStrategy/#btstrategy","text":"BtStrategy is a strategy container developed for use inside a BtEngine object. It defines trading strategies and outputs scores based on the input data, selected strategy, and configurable thresholds.","title":"BtStrategy"},{"location":"BtStrategy/#available-strategies","text":"","title":"Available Strategies"},{"location":"BtStrategy/#crossover","text":"Crossover is a strategy where two moving averages of close prices compared. The Short Moving Average (SMA) is used to capture recent trends in price changes while the Long Moving Average (LMA) records the long-term movement of the close price. Crossover generates a buy or sell signal when a change in the price movement trend is detected. The trend comparison is made by comparing the SMA and LMA of the current period to the previous one in a relational setting: Buy Signal: $SMA_i \\geq LMA_i \\ \\text{and } SMA_{i-1} \\leq LMA_{i-1}$ (On periods where SMA crosses over LMA) Sell Signal: $SMA_i \\leq LMA_i \\ \\text{and } SMA_{i-1} \\geq LMA_{i-1}$ (On periods where LMA crosses over SMA) Hence, the strategy is named \"Crossover\" in reference to the relations it aims to capture. Signal magnitude is not measured in this strategy and all trades will be made with BtEngine.max_trade_proportion (0.33) of the asset traded.","title":"Crossover"},{"location":"BtStrategy/#relative-strength-index","text":"Relative Strength Index (RSI) is a common strategy that, again, takes moving averages as its basis. However, RSI relies on the average change of close prices instead of the absolute price. Relative Strength (RS) is calculated and scaled to the range $[0, 100]$ to get the RSI score. RS and its rescaling is done as follows: $$RS=\\frac{\\text{Average Gains}}{\\text{Average Losses}}$$ $$RSI = 100-\\frac{100}{1+RS}$$ Where $\\text{Average Gains}$ and $\\text{Average Losses}$ are the moving averages of positive and negative changes in price respectively. A buy signal is typically produced when $RSI \\leq 30$ and a sell is often placed at $RSI \\geq 70$ . BtStrategy offers Linear, Exponential, and Logistic Scaling for RSI strategies with Logistic Scaling being the default and best performing option. (per our testing)","title":"Relative Strength Index"},{"location":"BtStrategy/#fibonacci-retracement","text":"Fibonacci Retracement is a strategy relying on drawing brackets between the high and low prices from a period brackets are defined as percentiles in the $[Lo_{i-t:i}, Hi_{i-t:i}]$ range and the levels are drawn from the Fibonacci sequence. ( $FibLevels = {0.236, 0.382, 0.618, 0.786}$ ) Signals are generated as follows: $$ \\mathrm{FibSignal}(P_i) = \\begin{cases} \\text{Buy} & \\text{if } P_i \\leq P_{38.2\\text{%}} \\ \\text{Hold} & \\text{if } P_i \\in (P_{38.2\\text{%}}, \\ P_{61.8\\text{%}}) \\ \\text{Sell} & \\text{if } P_i \\geq P_{61.8\\text{%}} \\end{cases} $$ Similar to RSI, signal magnitude is achieved by mapping calculated Fib percentile of the current price to range $[0, 1]$ using on of the Linear, Exponential, and Logistic Scaling functions implemented. Again, the default and best performing function is determined to be the Logistic Scaling. (per our testing)","title":"Fibonacci Retracement"},{"location":"BtStrategy/#ichimoku-cloud","text":"Ichimoku Cloud is a strategy built on the moving averages of the range between high and low prices. Having the base formula: $$\\mathrm{Span}(t) = \\frac{Hi_{i-t: t} - Lo_{i-t: t}}{2}$$ Multiple moving averages are calculated with differing inputs as $t$ . Tenkan-sen ( $=\\mathrm{Span}(9)$ ): Captures the average range in the shortest rolling window Kijun-sen ( $=\\mathrm{Span}(26)$ ): Captures the average range in the mid-range rolling window Senkou Span B ( $=\\mathrm{Line}(52)$ ): Captures the average range in the longest rolling window Senkou Span A ( $\\frac{\\text{Tenkan-sen} + \\text{Kijun-sen}}{2}$ ): Captures the range between short and medium rolling spans Signals are generated as follows: $$\\mathrm{Ichimoku} = \\begin{cases} Buy & \\text{if} \\ \\text{Tenkan-sen > Kijun-sen} \\text{ and} P_i > \\max (Senkou_A, \\ Senkou_B) Sell & \\text{if} \\ \\text{Tenkan-sen < Kijun-sen} \\text{ and} P_i < \\min (Senkou_A, \\ Senkou_B) Hold & \\text{if} \\ \\text{Any other outcome} \\end{cases} $$ Ichimoku cloud signals do not generate scores with known bounds or midpoints, making signal scaling difficult. The approach taken in generating a signal magnitude for this strategy relies on clipping the final output to the range $[0, 1]$ with the assumption that magnitudes over 1 indicate a significantly strong signal and magnitudes less than 0 similarly indicate a significantly weak signal. Scaling is handled by the following functions: $$\\mathrm{CloudBoundary} = \\begin{cases} Senkou_A & \\text{if } \\ Signal = 1 \\ Senkou_B & \\text{if } \\ Signal = -1 \\end{cases}$$ $$\\text{Raw Magnitude} = \\frac{|P_i - CloudBoundary|}{Hi_i - Lo_i}$$ $$Magnitude = \\begin{cases} 1 & \\text{if } \\ \\text{Raw Magnitude} \\geq 1 \\ \\text{Raw Magnitude} & \\text{if } \\ \\text{Raw Magnitude} \\in (0, 1) \\ 0 & \\text{if } \\ \\text{Raw Magnitude} \\leq 0 \\end{cases}$$","title":"Ichimoku Cloud"},{"location":"BtStrategy/#__init__-arguments","text":"strat: Literal['crossover', 'rsi_ma', 'rsi_ewma', 'fib_retracement', 'ichimoku_cloud'] : strategy to use when running a backtest","title":"__init__ Arguments"},{"location":"BtStrategy/#attributes","text":"strat -> str : Strategy to use on backtesting signal_scaler -> Callable : Signal magnitude mapper function to use depending on the selected strategy buy_threshold -> int : Buying signal threshold for RSI strategies sell_threshold -> int : Selling signal threshold for RSI strategies","title":"Attributes"},{"location":"BtStrategy/#methods","text":"","title":"Methods"},{"location":"BtStrategy/#set_thresholds","text":"sets the thresholds given a single value using buy_threshold = threshold; sell_threshold = (100-threshold) to keep a uniform range of signal generation space on both ends of RSI. Params: - threshold: int : threshold to determine buying and selling regions Returns: - None window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']], displayMath: [[\"$$\", \"$$\"], ['\\\\[', '\\\\]']], packages: { '[+]': ['mhchem'] } }, loader: { load: ['[tex]/mhchem'] }, }","title":"set_thresholds"},{"location":"Markowitz/","text":"Markowitz Markowitz perform optimization to the weights of a known portfolio through Modern Portfolio Theory (MPT). Added to the traditional MPT are Machine Learning models to predict stock returns and sentiment analysis adjust return expectations based on media outlook. Markowitz relies on ReturnPred , Sentiment , and Cache modules on the backend. None of the listed modules are user-facing. __init__ Arguments portfolio -> Portfolio : A Portfolio object containing stock symbols. market -> IndexSymbol : Market index symbol. horizon -> Days : Investment horizon in days. lookback -> Days : Historical data lookback period in days. rf_rate_pa -> Optional[float] : Risk-free rate of return per annum. (10 Year US Treasury yield if None) api_key_path -> Optional[str | os.PathLike] : Path to the .env file containing a NewsAPI key. api_key_var -> Optional[str] : Name of the environment variable containing the NewsAPI key. Attributes portfolio -> Portfolio : A Portfolio object containing stock symbols. names -> dict[StockSymbol, str] : Short names of the companies issuing the stocks. market -> yfinance.Ticker : Market index. market_name -> str : Name of the market index. (often times the symbol) rf -> float : Risk-free rate of return for the investment period. (not per annum) raw_close -> pandas.DataFrame : Historical closing prices of the stocks. periodic_return -> pandas.DataFrame : Periodic returns of the stocks. expected_returns -> pandas.DataFrame : Expected returns of the stocks. volatility -> pandas.Series : Volatility of the stocks. market_returns -> pandas.Series : Market returns. market_volatility -> float : Market volatility. rm -> float : Market expected return. (historical average) cov_matrix -> pandas.DataFrame : Covariance matrix of the stocks. beta -> list[float] : Beta values of the stocks. Methods optimize_return Optimize the portfolio for a target return. Parameters: target_return: float : Target return for the portfolio. additional_constraints: Optioonal[list] : Additional constraints formatted to be passed to scipy.optimize.minimize . bounds: tuple[float, float] : Tuple containing the lower and upper bounds for the weights. include_beta: bool : Include beta values in the optimization. record: bool : Record the optimization results in the Portfolio object. Returns: tuple[dict, scipy.optimize.OptimizeResult] : A tuple containing the optimized weights and the optimization result. optimize_volatility Optimize the portfolio for a target volatility. Parameters: target_volatility: float : Target volatility for the portfolio. additional_constraints: Optioonal[list] : Additional constraints formatted to be passed to scipy.optimize.minimize . bounds: tuple[float, float] : Tuple containing the lower and upper bounds for the weights. include_beta: bool : Include beta values in the optimization. record: bool : Record the optimization results in the Portfolio object. Returns: tuple[dict, scipy.optimize.OptimizeResult] : A tuple containing the optimized weights and the optimization result. efficient_frontier Plot the efficient frontier. Parameters: - target_input: Literal['return', 'volatility'] : The target input for the efficient frontier. - n: int : Number of points to plot on the efficient frontier. - save: bool : Save the plot as a .png file. Returns: - None","title":"Markowitz"},{"location":"Markowitz/#markowitz","text":"Markowitz perform optimization to the weights of a known portfolio through Modern Portfolio Theory (MPT). Added to the traditional MPT are Machine Learning models to predict stock returns and sentiment analysis adjust return expectations based on media outlook. Markowitz relies on ReturnPred , Sentiment , and Cache modules on the backend. None of the listed modules are user-facing.","title":"Markowitz"},{"location":"Markowitz/#__init__-arguments","text":"portfolio -> Portfolio : A Portfolio object containing stock symbols. market -> IndexSymbol : Market index symbol. horizon -> Days : Investment horizon in days. lookback -> Days : Historical data lookback period in days. rf_rate_pa -> Optional[float] : Risk-free rate of return per annum. (10 Year US Treasury yield if None) api_key_path -> Optional[str | os.PathLike] : Path to the .env file containing a NewsAPI key. api_key_var -> Optional[str] : Name of the environment variable containing the NewsAPI key.","title":"__init__ Arguments"},{"location":"Markowitz/#attributes","text":"portfolio -> Portfolio : A Portfolio object containing stock symbols. names -> dict[StockSymbol, str] : Short names of the companies issuing the stocks. market -> yfinance.Ticker : Market index. market_name -> str : Name of the market index. (often times the symbol) rf -> float : Risk-free rate of return for the investment period. (not per annum) raw_close -> pandas.DataFrame : Historical closing prices of the stocks. periodic_return -> pandas.DataFrame : Periodic returns of the stocks. expected_returns -> pandas.DataFrame : Expected returns of the stocks. volatility -> pandas.Series : Volatility of the stocks. market_returns -> pandas.Series : Market returns. market_volatility -> float : Market volatility. rm -> float : Market expected return. (historical average) cov_matrix -> pandas.DataFrame : Covariance matrix of the stocks. beta -> list[float] : Beta values of the stocks.","title":"Attributes"},{"location":"Markowitz/#methods","text":"","title":"Methods"},{"location":"Markowitz/#optimize_return","text":"Optimize the portfolio for a target return. Parameters: target_return: float : Target return for the portfolio. additional_constraints: Optioonal[list] : Additional constraints formatted to be passed to scipy.optimize.minimize . bounds: tuple[float, float] : Tuple containing the lower and upper bounds for the weights. include_beta: bool : Include beta values in the optimization. record: bool : Record the optimization results in the Portfolio object. Returns: tuple[dict, scipy.optimize.OptimizeResult] : A tuple containing the optimized weights and the optimization result.","title":"optimize_return"},{"location":"Markowitz/#optimize_volatility","text":"Optimize the portfolio for a target volatility. Parameters: target_volatility: float : Target volatility for the portfolio. additional_constraints: Optioonal[list] : Additional constraints formatted to be passed to scipy.optimize.minimize . bounds: tuple[float, float] : Tuple containing the lower and upper bounds for the weights. include_beta: bool : Include beta values in the optimization. record: bool : Record the optimization results in the Portfolio object. Returns: tuple[dict, scipy.optimize.OptimizeResult] : A tuple containing the optimized weights and the optimization result.","title":"optimize_volatility"},{"location":"Markowitz/#efficient_frontier","text":"Plot the efficient frontier. Parameters: - target_input: Literal['return', 'volatility'] : The target input for the efficient frontier. - n: int : Number of points to plot on the efficient frontier. - save: bool : Save the plot as a .png file. Returns: - None","title":"efficient_frontier"},{"location":"Portfolio/","text":"Portfolio Portfolio is an extension to the standard tuple class. The arguments passed on instantiation (stock symbols) will be stored in a tuple and can be accessed using numerical indices. Additionally, using stock symbols as string indices will return relevant information about the stock. __init__ Arguments *args: Stock symbols to be added to the portfolio. Attributes results : A nested dict containing stock information. First level keys: 'weights', 'expected_returns', 'volatility', 'beta', 'sharpe_ratio', 'sentiment' Second level keys: Stock symbols - optimum_portfolio_info : A dictionary containing summary information regarding the optimized portfolio. - Keys: 'target_return', 'target_volatility', 'weights', 'risk_per_return' - weights : A dictionary of stock symbols and their respective weights in the portfolio. - tickers : A yfinance.Tickers object containing initialized with stocks passed to Portfolio .","title":"Portfolio"},{"location":"Portfolio/#portfolio","text":"Portfolio is an extension to the standard tuple class. The arguments passed on instantiation (stock symbols) will be stored in a tuple and can be accessed using numerical indices. Additionally, using stock symbols as string indices will return relevant information about the stock.","title":"Portfolio"},{"location":"Portfolio/#__init__-arguments","text":"*args: Stock symbols to be added to the portfolio.","title":"__init__ Arguments"},{"location":"Portfolio/#attributes","text":"results : A nested dict containing stock information. First level keys: 'weights', 'expected_returns', 'volatility', 'beta', 'sharpe_ratio', 'sentiment' Second level keys: Stock symbols - optimum_portfolio_info : A dictionary containing summary information regarding the optimized portfolio. - Keys: 'target_return', 'target_volatility', 'weights', 'risk_per_return' - weights : A dictionary of stock symbols and their respective weights in the portfolio. - tickers : A yfinance.Tickers object containing initialized with stocks passed to Portfolio .","title":"Attributes"},{"location":"QuickStart/","text":"Installation NeoPortfolio can be installed through pip with the following command: python -m pip install NeoPortfolio You can visit the GitHub repository or PyPI page to access the source code. Quick Start NeoPortfolio offers optimization tools for pre-determined portfolios a search tool to find the optimal portfolio from an index's constituents. MPT Optimization for Pre-Determined Portfolio from src.NeoPortfolio import Portfolio, Markowitz # Create a portfolio object and pass it to the Markowitz class portfolio = Portfolio(['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']) markowitz = Markowitz( portfolio=portfolio, market='^GSPC', # S&P 500 horizon=21, lookback=252, rf_rate_pa=None, # Use 10-Year US Treasury yield if None api_key_path='path/to/api_key.env', # NewsAPI key api_key_var='YOUR_VAR_NAME' ) # Run the optimization weights, opt = markowitz.optimize_return(target_return=0.05, bounds=(0.05, 0.70), include_beta=True) print(weights) # Plot the efficient frontier markowitz.efficient_frontier('return', n=500) Automatic Portfolio Selection from src.NeoPortfolio import nCrOptimize ncr = nCrOptimize( market='^GSPC', # S&P 500 n=5, # Number of stocks in the portfolio target_return=0.05, horizon=21, lookback=252, api_key_path='path/to/api_key.env', # NewsAPI key api_key_var='YOUR_VAR_NAME' ) # Run the optimization results = ncr.optimize_space(bounds=(0.05, 0.70)) results.best_portfolio(display=True)","title":"Quick Start"},{"location":"QuickStart/#installation","text":"NeoPortfolio can be installed through pip with the following command: python -m pip install NeoPortfolio You can visit the GitHub repository or PyPI page to access the source code.","title":"Installation"},{"location":"QuickStart/#quick-start","text":"NeoPortfolio offers optimization tools for pre-determined portfolios a search tool to find the optimal portfolio from an index's constituents.","title":"Quick Start"},{"location":"QuickStart/#mpt-optimization-for-pre-determined-portfolio","text":"from src.NeoPortfolio import Portfolio, Markowitz # Create a portfolio object and pass it to the Markowitz class portfolio = Portfolio(['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']) markowitz = Markowitz( portfolio=portfolio, market='^GSPC', # S&P 500 horizon=21, lookback=252, rf_rate_pa=None, # Use 10-Year US Treasury yield if None api_key_path='path/to/api_key.env', # NewsAPI key api_key_var='YOUR_VAR_NAME' ) # Run the optimization weights, opt = markowitz.optimize_return(target_return=0.05, bounds=(0.05, 0.70), include_beta=True) print(weights) # Plot the efficient frontier markowitz.efficient_frontier('return', n=500)","title":"MPT Optimization for Pre-Determined Portfolio"},{"location":"QuickStart/#automatic-portfolio-selection","text":"from src.NeoPortfolio import nCrOptimize ncr = nCrOptimize( market='^GSPC', # S&P 500 n=5, # Number of stocks in the portfolio target_return=0.05, horizon=21, lookback=252, api_key_path='path/to/api_key.env', # NewsAPI key api_key_var='YOUR_VAR_NAME' ) # Run the optimization results = ncr.optimize_space(bounds=(0.05, 0.70)) results.best_portfolio(display=True)","title":"Automatic Portfolio Selection"},{"location":"nCrOptimize/","text":"nCrOptimize nCrOptimize is a class that performs optimization on a search space of nCr combinations of stocks from a market index. It employs aggressive elimination processes to reduce the members of the combination space to keep compute times reasonable. nCrOptimize is programmed to cache results on each iteration to retain information from interrupted runs. nCrOptimize relies on nCrEngine , ReturnPred , Sentiment , and Cache modules on the backend. None of the listed modules are user-facing. __init__ Arguments market -> IndexSymbol : Market index symbol. n -> int : Number of stocks in the portfolio. target_return -> float : Target return for the portfolio. horizon -> Days : Investment horizon in days. lookback -> Days : Historical data lookback period in days. max_pool_size -> Optional[int] : Maximum number of combinations to consider. api_key_path -> Optional[str | os.PathLike] : Path to the .env file containing a NewsAPI key. api_key_var -> Optional[str] : Name of the environment variable containing the NewsAPI key. Attributes api_key_path -> Optional[str | os.PathLike] : Path to the .env file containing a NewsAPI key. key_var -> Optional[str] : Name of the environment variable containing the NewsAPI key. portfolio_cache -> PortfolioCache : Cache.PortfolioCache object. portfolios -> list[Portfolio] : List of Portfolio objects created from combinations. market_returns -> pandas.Series : Market returns. rf_rate -> float : Risk-free rate of return for the investment period. (not per annum) Methods optimize_space Optimize the search space of nCr combinations. Parameters: - bounds: tuple[float, float] : Tuple containing the lower and upper bounds for the weights. Returns: - nCrResult : An object containing the results of the optimization.","title":"nCrOptimize"},{"location":"nCrOptimize/#ncroptimize","text":"nCrOptimize is a class that performs optimization on a search space of nCr combinations of stocks from a market index. It employs aggressive elimination processes to reduce the members of the combination space to keep compute times reasonable. nCrOptimize is programmed to cache results on each iteration to retain information from interrupted runs. nCrOptimize relies on nCrEngine , ReturnPred , Sentiment , and Cache modules on the backend. None of the listed modules are user-facing.","title":"nCrOptimize"},{"location":"nCrOptimize/#__init__-arguments","text":"market -> IndexSymbol : Market index symbol. n -> int : Number of stocks in the portfolio. target_return -> float : Target return for the portfolio. horizon -> Days : Investment horizon in days. lookback -> Days : Historical data lookback period in days. max_pool_size -> Optional[int] : Maximum number of combinations to consider. api_key_path -> Optional[str | os.PathLike] : Path to the .env file containing a NewsAPI key. api_key_var -> Optional[str] : Name of the environment variable containing the NewsAPI key.","title":"__init__ Arguments"},{"location":"nCrOptimize/#attributes","text":"api_key_path -> Optional[str | os.PathLike] : Path to the .env file containing a NewsAPI key. key_var -> Optional[str] : Name of the environment variable containing the NewsAPI key. portfolio_cache -> PortfolioCache : Cache.PortfolioCache object. portfolios -> list[Portfolio] : List of Portfolio objects created from combinations. market_returns -> pandas.Series : Market returns. rf_rate -> float : Risk-free rate of return for the investment period. (not per annum)","title":"Attributes"},{"location":"nCrOptimize/#methods","text":"","title":"Methods"},{"location":"nCrOptimize/#optimize_space","text":"Optimize the search space of nCr combinations. Parameters: - bounds: tuple[float, float] : Tuple containing the lower and upper bounds for the weights. Returns: - nCrResult : An object containing the results of the optimization.","title":"optimize_space"},{"location":"nCrResult/","text":"nCrResult nCrResult extends the standard list class and contains the results of the optimization performed by nCrOptimize for each combination of stocks. It provides methods to explore the optimized combination space and automatically create HTML reports for the best portfolios, outputted by Ipython.display.HTML and Ipython.display.display . Methods best_portfolio Display the best portfolio (determined by $score = \\frac{\\mu_{expected}}{\\sigma^2}$ ) Parameters: - display: bool : Create an HTML report and display it if True. Else return the results as a dictionary. Returns: - Optional[dict] : A dictionary containing the best portfolio's information. max_return Display the portfolio with the highest expected return. Parameters: - display: bool : Create an HTML report and display it if True. Else return the results as a dictionary. Returns: - Optional[dict] : A dictionary containing the portfolio with the highest expected return's information. min_volatility Display the portfolio with the lowest volatility. Parameters: - display: bool : Create an HTML report and display it if True. Else return the results as a dictionary. Returns: - Optional[dict] : A dictionary containing the portfolio with the lowest volatility's information. window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']], displayMath: [[\"$$\", \"$$\"], ['\\\\[', '\\\\]']], packages: { '[+]': ['mhchem'] } }, loader: { load: ['[tex]/mhchem'] }, }","title":"nCrResult"},{"location":"nCrResult/#ncrresult","text":"nCrResult extends the standard list class and contains the results of the optimization performed by nCrOptimize for each combination of stocks. It provides methods to explore the optimized combination space and automatically create HTML reports for the best portfolios, outputted by Ipython.display.HTML and Ipython.display.display .","title":"nCrResult"},{"location":"nCrResult/#methods","text":"","title":"Methods"},{"location":"nCrResult/#best_portfolio","text":"Display the best portfolio (determined by $score = \\frac{\\mu_{expected}}{\\sigma^2}$ ) Parameters: - display: bool : Create an HTML report and display it if True. Else return the results as a dictionary. Returns: - Optional[dict] : A dictionary containing the best portfolio's information.","title":"best_portfolio"},{"location":"nCrResult/#max_return","text":"Display the portfolio with the highest expected return. Parameters: - display: bool : Create an HTML report and display it if True. Else return the results as a dictionary. Returns: - Optional[dict] : A dictionary containing the portfolio with the highest expected return's information.","title":"max_return"},{"location":"nCrResult/#min_volatility","text":"Display the portfolio with the lowest volatility. Parameters: - display: bool : Create an HTML report and display it if True. Else return the results as a dictionary. Returns: - Optional[dict] : A dictionary containing the portfolio with the lowest volatility's information. window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']], displayMath: [[\"$$\", \"$$\"], ['\\\\[', '\\\\]']], packages: { '[+]': ['mhchem'] } }, loader: { load: ['[tex]/mhchem'] }, }","title":"min_volatility"}]}